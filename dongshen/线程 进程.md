[[操作系统期末考试]]
线程、进程和协程都是计算机程序中常用的并发编程模型，它们之间有以下几个区别：
1. 资源分配：进程是操作系统资源分配的基本单位，包括代码、数据、堆栈等，**每个进程都有独立的内存空间和系统资源**。而线程是进程的一个执行单元，**同一进程中的线程共享相同的内存空间和系统资源，并且可以独立运行，但线程之间的切换开销比进程小。**
2. 执行方式：进程和线程都是**抢占式调度**的，由操作系统负责调度，其执行方式是由操作系统控制的。而协程是**协作式调度**的，由程序员手动控制切换(Yield)，其执行方式可以更加高效和灵活。
3. 上下文切换：进程之间切换会涉及到大量的上下文切换、内存映射等操作，开销较大；线程之间切换开销相对较小；而协程的切换只需要保存少量上下文信息，开销最小。
4. 编程复杂度：进程和线程在编程时需要考虑同步、互斥、死锁等问题，编程复杂度较高；而协程相对于进程和线程来说，编程复杂度较低，但需要手动管理协程状态，编写的程序需要遵循协作式的调度逻辑。
5. 应用场景：进程通常用于分布式系统、操作系统等底层应用；线程一般用于网络服务、GUI编程等中层应用；协程通常用于高并发的服务器、游戏开发等上层应用。
总之，进程、线程和协程都是计算机程序中常用的并发编程模型，它们各有特点，在不同的应用场景下可以选择合适的模型来实现高效并发编程。
## System Call
Linux基础系统调用（syscall）是用户空间程序与内核之间的接口，通过系统调用可以让用户空间程序请求内核提供的服务，如文件操作、进程管理、网络通信等。在Linux中，系统调用通常使用软中断（software interrupt）方式实现。下面是Linux基础syscall的执行过程：

1. 用户空间程序通过指令int 0x80或sysenter**将控制权交给内核**；
2. CPU检测到中断并转入内核模式，保存用户态寄存器的值，并切换到内核态栈；
3. 内核根据传入的系统调用号，在系统调用表中查找相应的系统调用函数，并保存系统调用参数；
4. 系统调用函数根据参数进行处理，并返回系统调用结果；
5. 内核从系统调用返回，并将返回值存放在寄存器中；
6. CPU切换回用户态，将返回值传递给用户空间程序。
当使用sysenter指令进行系统调用时，可以绕过中断向量表的查找和处理过程，从而提高系统调用的执行效率。这里的关键在于，**在Linux内核启动时，会初始化中断向量表，并将所有的系统调用对应的中断号和中断处理函数的入口地址进行映射**。因此，当使用sysenter指令进行系统调用时，内核可以直接从该映射表中获取对应的中断处理函数的入口地址，从而实现快速执行。
需要注意的是，系统调用是一种特殊的函数调用，涉及到用户态和内核态之间的切换，因此系统调用会带来额外的开销。为了减少这种开销，Linux提供了一些优化技术，如vDSO（virtual dynamic shared object）和seccomp（secure computing）机制等，使得系统调用的执行更加高效、安全和可靠。

### fork
**fork** is an operation whereby a process **creates a copy of itself.**
It is usually implemented as a C standard library wrapper to the fork, clone, or other system calls of the kernel. 
For a process to start the execution of a different program, it first forks to create a copy of itself, creating a child process. **Then the child calls `exec` system call to overlay itself**: it ceases execution of its former program in favor of the other. 
The fork operation creates **a separate address space** for the child. The child process **has an exact copy of all the memory segments of the parent process**.
copy-on-write semantics are implemented and the physical memory need **not be actually copied**. Instead, virtual memory pages in both processes may refer to the same pages of physical memory **until one of them writes to such a page: then it is copied**. This optimization is important in the common case where the child process performs only a small set of actions before it ceases execution of its program in favour of the program to be started, and it requires very few, if any, of its parent's data structures.
hey can then inspect the call's **return value to determine their status, child or parent**, and act accordingly. child returns 0, parent returns the mark of child processes.
子进程从父进程的文件描述符副本开始。对于进程间通信，父进程通常会创建一个或多个管道，在fork进程之后，进程关闭它们不需要的管道端。
在发出一个**vfork**系统调用时，父进程被暂停，直至子进程完成执行或被新的可执行映像取代（通过系统调用之“exec”家族中的一项）。子进程借用父进程的MMU设置和内存页面，在父进程与子进程之间共享，不进行复制，如果子进程在任何共享页面中进行修改，不会创建新的页面，并且修改的页面对父进程同样可见。父进程会等待子进程执行，直到子进程调用`exec`创建自己的独立地址空间或者执行完退出为止。因为没有页面复制（消耗额外的内存），此技术在纯复制环境中使用exec时较普通fork更优化。
### exec
In computing, `exec` is a functionality of an operating system that **runs an executable file in the context of an already existing process, replacing the previous executable**. This act is also referred to as an **overlay**. It is especially important in Unix-like systems, although it exists elsewhere. As no new process is created, the process identifier **(PID) does not change**, but the machine code, data, heap, and stack of the process are replaced by those of the new program.

A file descriptor open remains open when an exec call is made  in the new process image, unless was `fcntl`ed with `FD_CLOEXEC` or opened with `O_CLOEXEC` (the latter was introduced in POSIX.1-2001). This aspect is used to specify the standard streams (stdin, stdout and stderr) of the new program.
A successful overlay **destroys the previous memory address space of the process,** and all its memory areas, that were not shared, are reclaimed by the operating system. Consequently, all its data that were not passed to the new program, or otherwise saved, become lost.
A successful exec replaces the current process image, so it cannot return anything to the program that made the call. Processes do have an exit status, but that value is collected by the parent process.
If an exec function does return to the calling program, an error occurs, the return value is −1,
### wait
In computer operating systems, a process (or task) may wait for another process to complete its execution. In most systems, a parent process can create an independently executing child process. The parent process may then issue a `wait` system call, which suspends the execution of the parent process while the child executes. **When the child process terminates, it returns an exit status to the operating system, which is then returned to the waiting parent process.** The parent process then resumes execution.
An operating system may provide variations of the wait call that allow a process to wait for any of its child processes to exit, or to wait for a single specific child process (identified by its process ID) to exit.
**Some operating systems issue a signal (`SIGCHLD`) to the parent process when a child process terminates,** notifying the parent process and allowing it to get the child process's exit status.
The exit status returned by a child process typically indicates whether the process terminated normally or abnormally. For normal termination, this status also includes the exit code (usually an integer value) that the process returned to the system.
When a child process terminates, it becomes a **zombie** process, and continues to exist as an entry in the system process table even though it is no longer an actively executing program. Under normal operation it will typically be immediately waited on by its parent, and then reaped by the system, **reclaiming the resource** (the process table entry). If a child is not waited on by its parent, it continues to **consume this resource indefinitely, and thus is a resource leak.** Such situations are typically handled with a special **"reaper" process** that locates zombies and retrieves their exit status, allowing the operating system to then deallocate their resources.
Conversely, a child process whose parent process terminates before it does becomes an orphan process. Such situations are typically handled with a special "root" (or "init") process, **which is assigned as the new parent of a process when its parent process exits**. This special process detects when an orphan process terminates and then retrieves its exit status, allowing the system to deallocate the terminated child process.
### exit
On many computer operating systems, a computer process terminates its execution by making an exit system call. More generally, an exit in a multithreading environment means that a thread of execution has stopped running. For resource management, the operating system **reclaims resources** (memory, files, etc.) that were used by the process. The process is said to be a dead process after it terminates. 
Under Unix and Unix-like operating systems, a process is started when its parent process executes a **fork** system call. The parent process may then **wait** for the child process to terminate, or may continue execution (**possibly forking off other child processes**). When the child process terminates ("dies"), either normally by calling exit, or abnormally due to a fatal exception or signal (e.g., SIGTERM, SIGINT, SIGKILL), an exit status is returned to the operating system and a SIGCHLD signal is sent to the parent process. The exit status can then be retrieved by the parent process via the **wait** system call. As the final step of termination, a primitive system exit call is invoked, **informing the operating system that the process has terminated and allows it to reclaim the resources used by the process.** That is the subroutine of cleanup
### kill(信号)
-9是信号
kill is a command, not a sys call. 
But kill is something of a *misnomer(误称）*; **the signal sent may have nothing to do with process killing**. The kill command is a wrapper around the `kill()` system call, which sends signals to processes or process groups on the system, referenced by their numeric process IDs (PIDs) or process group IDs (PGIDs).
There are many different signals that can be sent.  The default signal sent is `SIGTERM`. 
>**SIGINT** "Signal interrupt" The SIGINT signal is sent to a process by its controlling terminal when a user wishes to **interrupt** the process. This is typically initiated by pressing Ctrl+C
>**SIGKILL** "Signal kill" The SIGKILL signal is sent to a process to cause it to **terminate immediately (kill)**. In contrast to SIGTERM and SIGINT, this signal **cannot be caught or ignored, and the receiving process cannot perform any clean-up upon receiving this signal**. 
>**SIGTERM** "Signal terminate" The SIGTERM signal is sent to a process to request its **termination**. Unlike the SIGKILL signal, it **can be caught and interpreted or ignored by the process.** This allows the process to perform nice termination **releasing resources and saving state if appropriate**. SIGINT is nearly identical to SIGTERM.

## Handler
系统调用syscall()可以用来**注册或修改信号处理程序**。它的函数原型为：

```c
#include <unistd.h>
#include <sys/syscall.h>

long syscall(long number, ...);
```

其中，第一个参数number指定了要执行的系统调用号，后面的...表示该调用需要传入的参数列表。
在使用syscall()注册或修改信号处理程序时，需要使用sigaction()函数设置信号的处理方式、信号的被阻塞和解除阻塞时的行为等；signal()函数则设置信号的处理方式，但比较简单，只有两种处理方式：忽略信号或者执行默认的信号处理函数。
在信号处理程序被注册后，当系统产生一个信号时，内核就会向相应的进程发送这个信号，并将信号处理程序与该信号关联起来。当进程接收到信号时，会执行与信号关联的信号处理程序。
```C
#include <stdio.h>
#include <signal.h>

void sigterm_handler(int signum) {
    printf("Received SIGTERM signal, terminating...\n");
    // ...执行一些清理工作...
    exit(0);
}

#include <unistd.h>
#include <sys/syscall.h>
#include <signal.h>
#include <stdlib.h>

int main() {
    struct sigaction sa;
    sa.sa_handler = sigterm_handler;  // 设置信号处理函数
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);

    if (sigaction(SIGTERM, &sa, NULL) == -1) {
        perror("sigaction error");
        exit(1);
    }

    // ...执行一些其他操作...
    // 调用syscall()执行需要修改的系统调用
    syscall(SIGTERM, args);

    return 0;
}

#include <unistd.h>
#include <sys/syscall.h>
#include <signal.h>
#include <stdlib.h>

int main() {
    signal(SIGTERM, sigterm_handler);  // 设置信号处理函数

    // ...执行一些其他操作...
    // 调用syscall()执行需要修改的系统调用
    syscall(SIGTERM, args);

    return 0;
}

```
### vsyscall
一些不太敏感的系统调用放到用户态来做，确保安全的情况下更加性能。

## syscall ABI
在Linux系统中，当应用程序调用syscall时，其返回值通常存储在EAX寄存器中，即%eax。
在x86架构的Linux系统中，syscall使用的是系统调用号（system call number）标识需要执行的系统调用。系统调用号和参数都会被存储在寄存器中，例如使用EAX寄存器来存储系统调用号，EBX、ECX、EDX、ESI等寄存器来存储系统调用的参数。
对于x86_64架构的系统，则使用RAX寄存器来存储系统调用号，而将其他系统调用参数放置在RDI、RSI、RDX、R10、R8以及R9等寄存器中。系统调用结束后，操作系统会将返回值保存在RAX寄存器中，应用程序可以通过读取RAX寄存器的值来获得系统调用的返回值。

因此，针对不同的系统架构，我们可以根据对应的ABI（Application Binary Interface，应用二进制接口）规范来获取syscall的返回值。在每种架构的系统中，ABI都会规定如何使用寄存器来传递参数、如何进行函数调用和返回值处理等细节，从而确保不同的应用程序能够在相同的系统环境中运行并交互。

##### 如果并行线程过多，可能会出现以下性能问题：
1. **上下文切换开销增加**：当线程数量增加时，操作系统需要频繁地进行线程之间的上下文切换，将CPU资源分配给不同的线程。但是，上下文切换本身也会产生一定的开销，因此过多的线程会导致系统的运行效率降低。
2. **内存和缓存争用**：每个线程都需要占用一定的内存空间和CPU缓存，如果线程数目过多，可能会导致内存和缓存的争用情况加剧，从而导致性能下降。
3. **线程阻塞和竞争条件**：线程之间可能存在相互依赖和共享资源的情况，如果线程数目过多，就容易出现线程之间的**阻塞**和**竞争条件**，从而影响程序的稳定性和可靠性。
4. **调度延迟和饥饿现象**：在多核处理器中，线程之间可以并行执行，但是调度过程也需要时间，如果线程数目过多，就容易出现调度延迟和**饥饿**(一次拿到所有需要的资源) 现象，导致某些线程无法得到充分的CPU资源。

为了避免上述问题，应该尽可能控制并行线程的数量，并根据实际情况进行优化调整。例如，可以使用线程池技术来控制线程的数量和生命周期，减少不必要的上下文切换和内存开销；还可以使用锁和同步机制来避免竞争条件和阻塞现象。总之，合理地控制并行线程的数量和调度，才能保证多线程应用程序的高效、稳定和可靠性。

##### 换页的开销
在操作系统中，为了将物理内存资源充分利用，会使用虚拟内存技术来实现透明的内存管理。虚拟内存技术允许进程使用比其物理内存容量更大的虚拟地址空间，**当进程需要访问不在物理内存中的页面时，就会产生缺页中断（Page Fault），再从磁盘中读取所需页面到物理内存中，这个过程称为“换页”（Swap）。**

在进行换页时，由于需要访问外部设备磁盘，因此会产生较大的开销，主要包括以下几个方面：
1. **I/O延迟**：读取磁盘数据是一个相对较慢的操作，通常涉及到磁盘寻道、旋转等机械操作，尤其是当磁盘请求队列较长或者磁盘故障时，I/O延迟会显著增加。
2. **内存带宽开销**：当系统在进行页面置换时，需要将被置换出的页面写入到磁盘中，同时读取要置换的页面到内存中。这一过程需要**占用内存带宽，可能会影响其他正在运行的进程的性能**。
3. CPU时间片浪费：当进程发生缺页中断时，操作系统需要暂停当前进程的执行，进行页面置换和I/O操作，直到磁盘数据读取完毕并完成页面替换后才能继续运行。当进程需要等待I/O操作、发生缺页中断、或者由于其他原因导致暂停执行时，**操作系统会将CPU资源分配给其他处于就绪状态的进程，直到当前进程再次准备好执行为止**。这种切换过程称为上下文切换（Context Switch），包括保存当前进程的状态和加载另一进程的状态，上下文切换也会有比较多的时间占用。
4. 预取机制的不合理有可能会进一步拖累系统性能。空间本地性或者事件本地性不强的时候。
因此，为了减少换页带来的开销，可以采取以下措施：
1. 增加物理内存：如果系统物理内存容量充足，就可以减少内存页面置换的频率，从而降低I/O延迟和内存带宽开销。
2. 优化页面置换算法：选择合适的页面置换算法，如最近最少使用（LRU）算法、先进先出（FIFO）算法等，可以提高页面置换的效率，减少开销。
3. 提高磁盘性能：通过提高磁盘读写速度、增加磁盘缓存、调整磁盘调度策略等方法，可以降低磁盘I/O延迟，提高页面读写效率。
4. 减少进程数目和应用程序的内存占用：避免同时运行过多的进程和应用程序，可以减少页面置换的发生次数，降低CPU时间片的浪费。

总之，由于换页是一项关键的系统操作，它的开销会显著影响系统整体性能。因此，需要针对具体的应用场景和系统负载情况，选择合适的优化策略，以提高系统的性能和稳定性。

### LSCPU
超线程个数=逻辑CPU的个数
![[Pasted image 20230531203129.png]]
**real 整个程序从开始到结束的时间。
user 在用户态跑这个程序所用的时间，不包括被阻塞，在cpu上计算的时间。
sys 处在内核态的时间。
如果充分利用多核跑，real小于user
如果单核跑，real一般约等于user+sys，大于也可能
如果是IO密集型/缺页很多，real远大于user**
sleep就是进入内核态把这个程序标记为被阻塞，到时间再来唤醒。中间cpuidle或者执行别的进程。sleep的时间不在user也不在sys（在内核标记、唤醒的时间非常短。）
## Turbo Boost of Intel
CPUs don’t always need to run at their maximum frequency. Some programs are more dependent on memory to run smoothly, while others are CPU-intensive. Intel® Turbo Boost Technology is an energy-efficient solution to this imbalance: **it lets the CPU run at its base clock speed when handling light workloads, then jump to a higher clock speed for heavy workloads.**
Running at a lower clock rate (the number of cycles executed by the processor every second) allows the processor to use less power, which can **reduce heat and positively impact battery life in laptops**. But when more speed is needed, Intel® Turbo Boost Technology dynamically increases the clock rate to compensate. This is sometimes called “algorithmic overclocking”.

提高CPU频率可以提高运行速率的原因主要是增加了CPU的时钟周期，从而使得CPU在单位时间内可以处理更多的指令和数据。
当 CPU 的时钟频率提高时，每个时钟周期的长度就会变短，CPU 可以在同样的时间内完成更多的指令执行。例如，如果一个 CPU 的时钟频率为 2GHz（即每秒钟有 20亿个时钟周期），那么每个时钟周期的长度约为 0.5 纳秒。如果将时钟频率提高到 4GHz，那么每个时钟周期的长度就缩短到了 0.25 纳秒，CPU 在同样的时间内可以执行更多的指令，从而提高运行速率。
此外，提高 CPU 频率还可以使得 CPU 更快地读取和写入内存、缓存等数据结构，从而加快程序的执行速率。
不过，需要注意的是，频率并不是唯一决定 CPU 性能的指标，还有很多其他因素如微架构设计、指令集支持等对 CPU 的性能有重要影响。同时，提高 CPU 频率也会带来一定的热量问题和功耗消耗问题，需要适当调节 CPU 的供电和散热系统以保证稳定性。