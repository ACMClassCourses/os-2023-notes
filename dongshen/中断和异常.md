[[特权级]]
[[硬件中断和软件中断 硬中断和软中断]]
[[操作系统期末考试]]
中断是由硬件支持、软件配合做的
中断向量表：表里面全部是jump 跳到中断处理代码的位置。
发生中断的时候加上一个offset到表中找到jump函数，进行跳转
### 上下文切换
中断时期上下文为进程保持完全相同，理想情况下只需要保证寄存器的状态和内存的状态，但是缓存的状态如果发生了改变会暴露了上下文已经被切过了。
由于上下文切换需要保证内存上下文一致，**会访问到页表**，因此上下文切换必须有**内核态**来做。
为了减少上下文切换的开销，需要进行一些优化：
1. 一个是扫描寄存器的使用，如果是 没有用到的寄存器，就不进行load、store操作。
2. syscall merge，如果两个syscall之间的间隔足够，可以把这段不太长的时间等待过去。
	 syscall batching，就像store buffer一样，记下每一个syscall的操作，攒一个batching慢慢的做，只要保证静态分析中做的事情是相同的，就能保证这么多syscall按照原来的顺序是正确的。甚至会在内核中做一些常数传播的编译优化。
	_syscall merge的问题：_
	- 导致内核的膨胀，内核要记录太多的处理信息
	- 导致内核的安全问题，别的进程可以通过内核的信息得知别的进程的信息
	- 导致内核危害，内核要做的事情太多

#### 为什么需要中断/异常机制,目的是什么

一下特性是中断和异常分别提供的:

-   **支持cpu和设备之间的并行**(在有需要时记下当前的状态，转而执行响应的事件处理程序，待处理完成后再返回断点或调度其他程序)
-   **实时交互的需要**(即刻响应，响应之后还能返回断点继续执行)
-   **优先级支持**(对更紧急任务的支持)
-   **故障报警与处理**
-   **保护性操作需要,防止破坏**(在进入内核态时发生中断，发生权限变化，处理完内核态任务之后再改变权限返回，保护内核)
-   **并行和进程操作/交互的需要**(时间片)

#### 中断和异常的区别

从发生源角度和处理方式角度划分为了中断和异常. 但是他们处理问题的方式和思路本质是一样的.

中断指I/O设备发出,也成为外中断.外部事件
异常是正在执行的指令引发的,cpu执行指令本身出现问题=>响应错误/异常处理程序,执行系统调用(通过trap)

中断解决cpu和设备间并行操作;异常解决cpu执行指令时出现的问题处理(算数溢出/地址越界...)

外中断，也是中断，异步中断，是指来自处理器之外的中断信号，包括时钟中断、键盘中断、它机中断和外部设备中断。外中断又分==可屏蔽中断==和==不可屏蔽中断==，各个中断具有不同的优先级，表示事件的紧急程度，==在处理高一级中断时往往会部分或全部屏蔽低级中断==。因最开始的中断仅针对外中断，因此外中断也直接称作中断。

内中断，又称异常，同步中断，是指来自处理器内部的中断信号，通常是由于在程序执行过程中，**发现与当前指令关联的、不正常的或错误的事件**。==内中断不能被屏蔽，一旦出现必须立即予以响应并进行处理==，只是处理程序运行过程中可以选择是否屏蔽其它中断或屏蔽哪些中断。 内中断可细分为：  
* 访管中断，由系统程序执行访管指令引起，可以看做机器指令的一种扩充；  
* 硬件故障中断，如：电源失效、奇偶校验错误，总线超时；  
* 程序性中断，如：非法操作、地址越界、页面故障、调试指令、除数为0和浮点溢出等。

中断由外部的中断控制器进行触发和响应.  
异常由cpu内部的中断处理器电路控制.

中断和异常的区别
![[Pasted image 20230223094133.png]]
关于它们的区别有两点是需要注意的：  
平常所说的屏蔽中断是不包括异常的，即异常不会因为CPU的IF位被清（关中断，指令：cli）而受影响，比如缺页异常，即使关了中断也会触发CPU的处理，回答了我上面红色部分疑问。  
通常说的int 80h这种系统调用使用的中断方式实际上硬件上是理解为异常处理的，因此也不会被屏蔽掉，这也很好理解，int 80h这种中断方式是程序里主动触发的，对于CPU来说属于同步事件，因此也就属于异常的范畴。

### 为什么中断处理过程中不能被阻塞，而异常处理过程却可以？

这是一个从解决问题考虑的设计思路问题,中断是外部设备发出, 你没办法决定是否可以忽略,所以只能立刻响应, 至于做不做事是可以决定的.  
异常所提供的服务本就是当前进程所需要的，故而当进程需要阻塞的时候，便会在异常处理程序中设置阻塞。所以它是你自己可控的你可以决定它是否可以阻塞.

## 中断/异常分类

图1

  

  

![](https://pic1.zhimg.com/80/v2-2003613a2b6bb8be504675c79dbc8a54_720w.webp)

  
Scannable Document on Jan 6, 2021 at 9_18_46 AM.png

按中断源进行分类：发出中断请求的设备称为中断源。按中断源的不同，中断可分为  
内中断：即程序运行错误引起的中断  
外中断：即由外部设备、接口卡引起的中断  
软件中断：由写在程序中的语句引起的中断程序的执行，称为软件中断

允许/禁止(开/关)中断： CPU通过指令限制某些设备发出中断请求，称为屏蔽中断。从CPU要不要接收中断即能不能限制某些中断发生的角度 ，中断可分为  
可屏蔽中断 ：  
可被CPU通过指令限制某些设备发出中断请求的中断， 那是不是意味着进中断时disable整个中断，其实disable的都是可屏蔽中断？  
不可屏蔽中断：  
不允许屏蔽的中断如电源掉电

可屏蔽中断，  
I/O设备发出的所有中断请求（IRQ）都产生可屏蔽中断，一个屏蔽的中断只要还是屏蔽的，控制单元就可以忽略它。  
非屏蔽中断，有一些危险的事件才能引起非屏蔽中断，例如硬件故障，非屏蔽中断总是由CPU辨认。

## 中断/异常工作机制

硬件软件同时支持才能完成.  
由硬件捕获响应,软件识别类型然后处理.  
每个中断/异常都有个号码,由硬件设计者或者操作系统设计者定义

大致流程:  
硬件捕获中断(某个针脚高电压)->根据内容按规矩编码(中断码)->写入中断寄存器  
cpu执行指令周期的最后时刻扫描中断寄存器->暂停当前程序->保护现场->根据中断码去中断向量表查询->找到地址及相关状态参数->执行中断程序->恢复

## 中断/异常的软硬件支持结构

os:  
操作系统设计时,提前设置中断/异常处理程序和向量表  
设计和实现中断处理程序  
设计处理程序的向量表  
运行时响应中断

中断码: 中断硬件对中断内容按规则编码,送入程序状态字寄存器(PSW)的相应位 中断向量表: 硬件查的表 映射中断处理程序 中断向量: 它是内存单元 存储处理程序入口地址,程序运行所需的处理机状态字

硬件:  
中断寄存器:  
保存中断信号  
cpu响应:  
在指令执行周期最后时刻扫描中断寄存器,看是否有  
判断是否允许中断

硬件的工作:(捕获/响应)  
* 捕获中断源请求  
* 响应  
* 控制权交给特定处理程序  
软件的工作:(处理)  
* 识别中断/异常类型  
* 完成处理(软件本身为处理程序)

## 实施/保护模式

在X86中，分为实模式和保护模式，实模式通常是CPU启动到BIOS再到操作系统启动前的这段时间，操作启动初始化完成进入到保护模式。

## 补充知识

常见异常:

-   算数溢出
-   除零
-   取数奇偶校验错
-   trap指令(system call)
-   硬件改变cpu执行流程
-   地址越界
-   页错误/故障
-   保护性异常(写仅读内存)
-   断点指令

常见中断:

-   I/O中断
-   时钟中断
-   硬件故障

图2

中断允许触发器：在CPU内部设置一个中断允许触发器，只有该触发器置“1”，才允许中断；置“0”，不允许中断。

指令系统中，开中断指令，使中断触发器置“1” 关中断指令，使中断触发器置“0”

中断优先级：为了管理众多的中断请求，需要按每个（类）中断处理的急迫程度，对中断进行分级管理，称其为中断优先级。在有多个中断请求时，总是响应与处理优先级高的设备的中断请求。

中断嵌套：当CPU正在处理优先级较低的一个中断，又来了优先级更高的一个中断请求，则CPU先停止低优先级的中断处理过程，去响应优先级更高的中断请求，在优先级更高的中断处理完成之后，再继续处理低优先级的中断，这种情况称为中断嵌套。

中断又可以分为可屏蔽中断和非可屏蔽中断，  
中断屏蔽是指 禁止 CPU 响应或禁止中断产生。前者是指 CPU 暂时不响应中断，等中断开放了被屏蔽的中断才能被响应，防止同级或高级的中断影响。后者是中断的事件发生时直接不允许提出中断请求也不能通知 CPU。

多重中断有几种处理方法，一种是串行处理，CPU 响应中断的时候屏蔽其它部分或所有中断；第二种是即时处理，运行中断的过程中，如果出现程序性中断（异常），一般情况表明此时中断处理程序有异常，应对其进行立即响应；第三种是嵌套处理，对于有些必须处理的高优先级的中断事件，采用屏蔽的方法不妥，因此允许某些中断处理程序时依然能够响应中断。操作系统必须预先规定每类中断的优先级，中断嵌套一般不会超过 3 重，过多嵌套会增加系统不必要的开销。

## 系统调用

系统调用使用trap实现, 是用户态到内核态的唯一入口(调用操作系统接口使用特权指令)  
特殊指令:  
是trap/访管指令,调用不同系统接口的统一入口,根据号和参数区分  
流程:  
通过trap一发异常-> 用户态切换到内核态->传参执行

### 用户参数如何传入内核

三种方式:

1.  trap指令自带参数(数量有限)
2.  通用寄存器,通用方案,寄存器个数有限
3.  内存中专门对战区

### 地址空间
地址空间的约定：一般用户和内核的地址空间在相差比较大的地方。cache攻击
MMIO PIO
Memory Map IO and Port IO
内核嵌套中断
page fault是异常
异常向量表的设置：CPU上电之后立即执行，是系统初始化的主要工作之一，在开启中断和启动第一个应用之前。
内核运行的时候可能会有嵌套中断：
1. 内核执行过程中发生了缺页(用户的地址和内核相差很多的目的就是尽量减少内核的页表被swap)
2. 内核执行过程中出现外部设备中断
3. 内核接收到别的核的用户程序主动发的syscall
![[SYSCALL传参数.jpg]]
但是用户态可以利用构造一个非法的指针，通过syscall攻击内核，内核翻译这些虚拟地址时就会造成各种问题，于是内核就会做相应的检查，防止出现一个未映射区域或者非法访问，如果是page fault，直接帮它call swap page就行
FixSC：flexible syscall，如果有多出来的核，可以给用户和内核各一个数据页，拿出一个核专门做在内核和用户态之间传递相关数据，避免syscall的开销；

## 时钟中断
时钟中断（Clock Interrupt）是一种计算机硬件中断，它是由 CPU 内部的硬件定时器产生的，用于确保操作系统和应用程序在运行过程中能够获得适当的时间片并进行调度。

当 CPU 启动时，定时器开始计数。当定时器的计数值达到预设的阈值时，CPU 就会产生一个时钟中断。时钟中断会暂停正在执行的进程，并将 CPU 的控制权移交给操作系统内核来处理。在内核中，时钟中断通常被用来执行以下几个任务：

1. 时间管理：时钟中断可以帮助操作系统跟踪时间的流逝，从而保证正确地记录日志、备份数据等。
2. 进程调度：时钟中断可以触发进程调度，使得操作系统能够按照特定的算法决定哪些进程获得 CPU 的使用权。
3. 虚拟内存管理：时钟中断可以触发虚拟内存管理机制，从而允许操作系统重新分配页面并回收未使用的内存。

时钟中断的频率通常是固定的，且与 CPU 的主频有关。例如，在一个 1 GHz 的 CPU 上，时钟中断通常以每秒 1000 次的速度运行。操作系统可以根据需要调整时钟中断的频率，以实现更好的性能和功耗平衡。

总之，时钟中断是计算机硬件中的一种机制，它可以帮助操作系统跟踪时间的流逝、执行进程调度和虚拟内存管理等任务。